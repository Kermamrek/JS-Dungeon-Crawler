<html>
	<head>
		<title>Dungeon Crawler</title>
		<style>
			body 
			{ 
				margin: 0px; 
			}
			#game
			{
				overflow: hidden;
				height: 100%;
			}
			#options
			{
				padding-left: 3px;
				float: right;
				width: 150px;
				height: 100%;
				color: white;
				background-color:#132538;
			}
		</style>
	</head>
	<body>
		<div id = "options">
			options and stuff would go here
		</div>
		<div id = "game"></div>
		<script src='./THREE/three.min.js'></script>
		<script src='./THREE/THREEx.KeyboardState.js'></script>
		<script>
			var LOOKSPEED = 0.03;
			var MOVESPEED = 0.05;
			var PLAYERSIZE = 0.2;
			var FOV = 70;
			
			window.addEventListener( 'resize', onWindowResize, false );
			
			function onWindowResize()
			{
				camera.aspect = game.offsetWidth/game.offsetHeight;
				camera.updateProjectionMatrix();
				
				renderer.setSize(game.offsetWidth, game.offsetHeight);

			}
			
			function de2ra(degree)
			{ 
				return degree*(Math.PI/180); 
			}
			
			function addWall(x, y)
			{
				var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1), wallMat);
				cube.position.set(x,0,y);
				scene.add(cube);
			}
			
			var game = document.getElementById("game");
			
			var scene = new THREE.Scene();
			scene.fog = new THREE.Fog(0x000000, 0.1, 10);
			
			var camera = new THREE.PerspectiveCamera(FOV, game.offsetWidth/game.offsetHeight, 0.01, 30);
			camera.position.set(2, 0.2, 6);
			
			var keyboard = new THREEx.KeyboardState();

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(game.offsetWidth, game.offsetHeight);
			game.appendChild(renderer.domElement);
			
			var wallTex = THREE.ImageUtils.loadTexture('./images/wall.png');
			var celingTex = THREE.ImageUtils.loadTexture('./images/celing.png');
			var floorTex = THREE.ImageUtils.loadTexture('./images/floor.png');
			var goonTex = THREE.ImageUtils.loadTexture('./images/goon.png');
			
			wallTex.magFilter = THREE.NearestFilter;
			var wallMat = new THREE.MeshBasicMaterial({map: wallTex});
			
			floorTex.magFilter = THREE.NearestFilter;
			floorTex.wrapS = THREE.RepeatWrapping;
			floorTex.wrapT = THREE.RepeatWrapping;
			floorTex.repeat.set(35, 35);
			var floorMat = new THREE.MeshBasicMaterial({map: floorTex});
			var floor = new THREE.Mesh(new THREE.PlaneGeometry(35, 35), floorMat);
			floor.position.set(0,-0.5,0);
			floor.rotation.x = de2ra(-90);
			scene.add(floor)
			
			celingTex.magFilter = THREE.NearestFilter;
			celingTex.wrapS = THREE.RepeatWrapping;
			celingTex.wrapT = THREE.RepeatWrapping;
			celingTex.repeat.set(35, 35);
			var celingMat = new THREE.MeshBasicMaterial({map: celingTex});
			var celing = new THREE.Mesh(new THREE.PlaneGeometry(35, 35), celingMat);
			celing.position.set(0,0.5,0);
			celing.rotation.x = de2ra(90);
			scene.add(celing)

			goonTex.magFilter = THREE.NearestFilter;
			var goonMat = new THREE.MeshBasicMaterial({map: goonTex, transparent: true});
			
			function mob(x,y)
			{
				this.geometry =	new THREE.Mesh(new THREE.PlaneGeometry(0.9, 0.9), goonMat);
				this.geometry.position.set(x, -0.05, y);
				scene.add(this.geometry);
				this.dead = false;
				this.update = function()
				{
					this.geometry.lookAt(new THREE.Vector3(
						camera.position.x,
						this.geometry.position.y,
						camera.position.z));
				}
				this.glib = function()
				{
					if(this.dead == false){
						scene.remove(this.geometry);
						for(var i=0; i < 200; i++)
						{
							console.log('foo');
							var Vx = (Math.random()*0.1)-0.05;
							var Vy = Math.random()*0.04;
							var Vz = (Math.random()*0.1)-0.05;
							particles.push(new particle(this.geometry.position.x, this.geometry.position.y, this.geometry.position.z, Vx, Vy, Vz, 0.3, 0.001, 0.05, 0xff0000));
						}
						this.dead = true;
					}
				}
			}
			
			var particles = [];
			var goon0 = new mob(2, 2);
			
			function particle(x, y, z, Vx, Vy, Vz, bounce, weight, size, color)
			{	
				this.mat = new THREE.MeshBasicMaterial({color: color});
				this.geometry = new THREE.Mesh(new THREE.PlaneGeometry(size, size), this.mat);
				this.geometry.position.set(x, y, z);
				scene.add(this.geometry);

				this.update = function()
				{
					this.geometry.lookAt(camera.position);
					if (this.geometry.position.y < -0.5)
					{
						Vx *= bounce;
						Vy *= -bounce;
						Vz *= bounce;
						this.geometry.position.y = -0.5;
					}
					if (this.geometry.position.y > 0.5)
					{
						Vx *= bounce;
						Vy *= -bounce;
						Vz *= bounce;
						this.geometry.position.y = 0.5;
					}
					this.geometry.position.x += Vx;
					this.geometry.position.y += Vy;
					this.geometry.position.z += Vz;
					Vy -= weight;	
				}
			}
	
			var dungeon = 
				[[1,1,1,1,1],
				[1,0,0,0,1],
				[1,0,0,0,1],
				[1,0,0,0,1],
				[1,1,0,1,1],
				[1,0,0,0,1],
				[1,0,0,0,1],
				[1,0,0,0,1],
				[1,1,1,1,1]];
				
			for(var y = 0; y < dungeon.length; y++)
			{
				for(var x = 0; x < dungeon[0].length; x++)
				{
					if( dungeon[y][x] == 1 )
					{
						addWall(x, y);					
					}
				}
			}

			var render = function () {
				requestAnimationFrame(render);
				handleMovement();
				goon0.update();
				for(var i in particles)
				{
					particles[i].update();
				}
				renderer.render(scene, camera);
			};
			
			function handleMovement()
			{
				if( keyboard.pressed("F") )
				{
					goon0.glib();
				}
				if( keyboard.pressed("Q") )
				{
					camera.rotation.y += LOOKSPEED;
				}
				if( keyboard.pressed("E") )
				{
					camera.rotation.y -= LOOKSPEED;
				}
				
				if( keyboard.pressed("W"))
				{
					camera.translateZ( -MOVESPEED-PLAYERSIZE );
					if(dungeon[Math.round(camera.position.z)][Math.round(camera.position.x)] == 1)
					{
						camera.translateZ( MOVESPEED + PLAYERSIZE );
					}
					else
					{
						camera.translateZ( PLAYERSIZE );
					}
				}
				if( keyboard.pressed("S"))
				{
					camera.translateZ( MOVESPEED+PLAYERSIZE );
					if(dungeon[Math.round(camera.position.z)][Math.round(camera.position.x)] == 1)
					{
						camera.translateZ( -MOVESPEED-PLAYERSIZE );
					}
					else
					{
						camera.translateZ( -PLAYERSIZE );
					}
				}
				if( keyboard.pressed("A"))
				{
					camera.translateX( -MOVESPEED -PLAYERSIZE );
					if(dungeon[Math.round(camera.position.z)][Math.round(camera.position.x)] == 1)
					{
						camera.translateX( MOVESPEED + PLAYERSIZE );
					}
					else
					{
						camera.translateX( PLAYERSIZE );
					}
				}
				if( keyboard.pressed("D"))
				{
					camera.translateX( MOVESPEED+PLAYERSIZE );
					if(dungeon[Math.round(camera.position.z)][Math.round(camera.position.x)] == 1)
					{
						camera.translateX( -MOVESPEED-PLAYERSIZE );
					}
					else
					{
						camera.translateX( -PLAYERSIZE );
					}
				}
				
				floor.position.set(camera.position.x, -0.5, camera.position.z);
				celing.position.set(camera.position.x, 0.5, camera.position.z);
				floorTex.offset.x = camera.position.x;
				floorTex.offset.y = -camera.position.z;
				celingTex.offset.x = camera.position.x;
				celingTex.offset.y = camera.position.z;
			}

			render();
		</script>
	</body>
</html>
